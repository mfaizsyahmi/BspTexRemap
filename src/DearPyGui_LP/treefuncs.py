''' treefuncs.py
    Copyright (c) 2023 M Faiz Syahmi @ kimilil
    Released under MIT License

    functions for parsing the tree generated by the DpgLayoutGrammar class
'''
import dearpygui.dearpygui as dpg
from .mappings import DPG_NODE_KW_MAP
from logging import getLogger
log = getLogger(__name__)


def get_node_name(node):
    return node.element.name if hasattr(node.element, "name") else None
_n = get_node_name

def parse_alnum(node):
    ''' only child is either r_str or r_num
    '''
    if _n(node.children[0]) == "r_str":
        return node.children[0].string[1:-1]
    elif _n(node.children[0]) == "r_num":
        if "." in node.children[0].string:
            return float(node.children[0].string)
        else:
            return int(node.children[0].string)

def parse_listval(node):
    ''' hierarchy:
        Choice cs_listval
        ╰─Sequence
          ╰─Token [ or (
          ╰─List
            ╰─Choice c_alnum <- parse these
            ╰─Token ,
            ╰─(repeat the above)
          ╰─Token ] or )
    '''
    result = []
    for li in node.children[0].children[1].children:
        if _n(li) == "c_alnum":
            result.append(parse_alnum(li))
    return result

def parse_value(node):
    ''' only child is either c_alnum OR cs_listval
    '''
    if _n(node.children[0]) == "c_alnum":
        return parse_alnum(node.children[0])
    elif _n(node.children[0]) == "cs_listval":
        return parse_listval(node.children[0])

def parse_kvlist(node):
    ''' hierarchy:
        Optional s_kvlist
        ╰─Sequence
          ╰─Token (
          ╰─List
            ╰─Choice cs_kv
              ╰─Sequence
                ╰─t_negate
                ╰─r_key
              OR
              ╰─Sequence
                ╰─r_key
              OR
              ╰─Sequence
                ╰─r_key
                ╰─Token =
                ╰─c_value
                  ╰─c_alnum OR
                  ╰─cs_listval
            ╰─Token ,
            ╰─(repeat the above)
          ╰─Token )
    '''
    result = {}
    #             sequence                  Sequence    List        choice
    kv_seqs = [x.children[0] for x in node.children[0].children[1].children \
                if _n(x)=="cs_kv"]
    for kv_seq in kv_seqs:
        ''' len corresponds to type of seq
            1: flag
            2: !flag
            3: key = value[alnum|list]
        '''
        if len(kv_seq.children) == 1: # assume !flag --> {flag:True}
            result[kv_seq.children[-1].string] = True
        elif len(kv_seq.children) == 2: # assume !flag --> {flag:False}
            result[kv_seq.children[-1].string] = False
        else:
            result[kv_seq.children[0].string] = parse_value(kv_seq.children[-1])
    return result


def parse_dpg_elem(node,parent=None):
    ''' NOTES:
        c_elname is node.children[0]
        get kw map from the string attr of c_elname
        s_kvlist is OPTIONALLY in node.children[1]
        c_children is somewhere in node.children
        dpg children is 2 levels inside c_children, with names c_value or s_elem
    '''
    # print("PARENT:",parent)
    if _n(node) == "START":
        return parse_dpg_elem(node.children[0].children[0], parent)
    elif _n(node) == "c_value":
        if not parent:
            parent = dpg.last_container()
        content = parse_value(node)
        if type(content) in (str,): # strip string
            content = content.strip()
        if type(content) in (str,float,int): # str/int/float content --> add_text

            self = dpg.add_text(content,parent=parent,wrap=0)
        elif type(content) in (list,): # list content --> add_listbox
            self = dpg.add_listbox(content, parent=parent)
        return self

    elif _n(node) != "s_elem" \
    or node.children[0].string not in DPG_NODE_KW_MAP: return

    dpg_fn, def_kwargs, child_content_slice = DPG_NODE_KW_MAP[node.children[0].string]

    if _n(node.children[1]) == "s_kvlist":
        this_kwargs = def_kwargs | parse_kvlist(node.children[1])
    else:
        this_kwargs = {} | def_kwargs

    this_kwargs["parent"] = parent or dpg.last_container()
    # print(dpg_fn, this_kwargs)

    if child_content_slice:
        node_with_the_children = next((x for x in node.children \
                                       if _n(x)=="c_children"),None)
        #print(json.dumps(node_props(node_with_the_children,""), indent=4))
        if node_with_the_children:

            sliced = [x.children[0] \
                      for x in node_with_the_children.children[child_content_slice]]
            #print("SLICED", sliced)
            if child_content_slice.stop > 1:
                content = [parse_value(x) for x in sliced]
            elif child_content_slice.stop == 1 and len(sliced):
                content = parse_value(sliced[0])
            else:
                content = ""
        else:
            content = ""

        self = dpg_fn(content, **this_kwargs)

    else:
        self = dpg_fn(**this_kwargs)

        children = next((x.children for x in node.children if _n(x)=="c_children"),None)
        for child in children: # these are choice elements
            # recurse create children
            parse_dpg_elem(child.children[0], self)

    # print("created:", self)
    return self

