''' treefuncs.py
    Copyright (c) 2023 M Faiz Syahmi @ kimilil
    Released under MIT License

    functions for parsing the tree generated by the DpgLayoutGrammar class
'''
import dearpygui.dearpygui as dpg
import json
from .mappings import DPG_NODE_KW_MAP, BINDINGS, CALLBACKS
from logging import getLogger
log = getLogger(__name__)


def get_node_name(node):
    return node.element.name if hasattr(node.element, "name") else None
_n = get_node_name

def swap_kwargs_callback(kwargs):
    ''' given kwargs, if callback is set and found in CALLBACKS mapping, 
        then swap with the callable value
        (kawrgs is mutable so it's passed by ref)
    '''
    if "callback" in kwargs and kwargs["callback"] in CALLBACKS:
        kwargs["callback"] = CALLBACKS[kwargs["callback"]]


# DEBUG FUNCTION
# Returns properties of a node object as a dictionary:
def node_props(node, path):
    this_name = node.element.name if hasattr(node.element, 'name') else None,
    this_element = node.element.__class__.__name__,
    this_path = f"{path}->{this_name[0]}" # {this_element[0]}:
    return {
        '_path':this_path,
        'start': node.start,
        'end': node.end,
        'name': node.element.name if hasattr(node.element, 'name') else None,
        'element': node.element.__class__.__name__,
        'string': node.string,
        'children': {i:o for i,o in enumerate(get_children(node.children, this_path))}
    }

# Recursive method to get the children of a node object:
def get_children(children, path):
    return [node_props(c, path) for c in children]    


def parse_alnum(node):
    ''' only child is either r_str or r_num
    '''
    if _n(node.children[0]) == "r_str":
        return node.children[0].string[1:-1]
    elif _n(node.children[0]) == "r_num":
        if "." in node.children[0].string:
            return float(node.children[0].string)
        else:
            return int(node.children[0].string)

def parse_listval(node):
    ''' hierarchy:
        Choice cs_listval
        ╰─Sequence
          ╰─Token [ or (
          ╰─List
            ╰─Choice c_alnum <- parse these
            ╰─Token ,
            ╰─(repeat the above)
          ╰─Token ] or )
    '''
    result = []
    for li in node.children[0].children[1].children:
        if _n(li) == "c_alnum":
            result.append(parse_alnum(li))
    return result

def parse_value(node):
    ''' only child is either c_alnum OR cs_listval
    '''
    if _n(node.children[0]) == "c_alnum":
        return parse_alnum(node.children[0])
    elif _n(node.children[0]) == "cs_listval":
        return parse_listval(node.children[0])

def parse_kvlist(node):
    ''' hierarchy:
        Optional s_kvlist
        ╰─Sequence
          ╰─Token (
          ╰─List
            ╰─Choice cs_kv
              ╰─Sequence
                ╰─t_negate
                ╰─r_key
              OR
              ╰─Sequence
                ╰─r_key
              OR
              ╰─Sequence
                ╰─r_key
                ╰─Token =
                ╰─c_value
                  ╰─c_alnum OR
                  ╰─cs_listval
            ╰─Token ,
            ╰─(repeat the above)
          ╰─Token )
    '''
    result = {}
    #             sequence                  Sequence    List        choice
    kv_seqs = [x.children[0] for x in node.children[0].children[1].children \
                if _n(x)=="cs_kv"]
    for kv_seq in kv_seqs:
        ''' len corresponds to type of seq
            1: flag
            2: !flag
            3: key = value[alnum|list]
        '''
        if len(kv_seq.children) == 1: # assume !flag --> {flag:True}
            result[kv_seq.children[-1].string] = True
        elif len(kv_seq.children) == 2: # assume !flag --> {flag:False}
            result[kv_seq.children[-1].string] = False
        else:
            result[kv_seq.children[0].string] = parse_value(kv_seq.children[-1])
    return result

def parse_bindings(node, item_tag):
    ''' hierarchy
        Repeat s_bindings (0 or more of...)
        ╰─Sequence
          ╰─Token :
          ╰─Choice c_binding
          ╰─Token (
          ╰─Choice c_alnum
          ╰─Token )
        ╰─(repeat the above)
    '''
    if not (elem := next((x for x in node.children \
                          if _n(x)=="s_bindings"),None)): return
    for binding in elem.children:
        bind_type = binding.children[1].string.lower()
        bind_tag  = parse_alnum(binding.children[3])
        
        if bind_type in BINDINGS:
            # call the mapped binding fn
            BINDINGS[bind_type](item_tag, bind_tag)


def parse_dpg_elem(node,parent=None):
    ''' NOTES:
        c_elname is node.children[0]
        get kw map from the string attr of c_elname
        s_kvlist is OPTIONALLY in node.children[1]
        c_children is somewhere in node.children
        dpg children is 2 levels inside c_children, with names c_value or s_elem
    '''
    if _n(node) == "START":
        log.debug("PARSING START OF LAYOUT. parent: %s", parent)
        # parse s_elem child nodes, as there could be top level comments
        elements = [x.children[0] for x in node.children if _n(x.children[0])=="s_elem"]
        for elem in [x.children[0] for x in node.children if _n(x.children[0])=="s_elem"]:
            parse_dpg_elem(elem,parent)
        return
        
    elif _n(node) == "c_value":
        if not parent:
            parent = dpg.last_container()
        content = parse_value(node)
        if type(content) in (str,): # strip string
            content = content.strip()
        if type(content) in (str,float,int): # str/int/float content --> add_text

            self = dpg.add_text(content,parent=parent,wrap=0)
        elif type(content) in (list,): # list content --> add_listbox
            self = dpg.add_listbox(content, parent=parent)
        return self

    elif _n(node) != "s_elem" \
    or node.children[0].string not in DPG_NODE_KW_MAP: 
        log.warning("node fail match! node name: %s == s_elem", _n(node))
        log.warning("node fail match! elem name: %s ", node.children[0].string)
        return

    dpg_fn, def_kwargs, child_content_slice = DPG_NODE_KW_MAP[node.children[0].string]

    if _n(node.children[1]) == "s_kvlist":
        this_kwargs = def_kwargs | parse_kvlist(node.children[1])
    else:
        this_kwargs = {} | def_kwargs

    this_kwargs["parent"] = parent or dpg.last_container()
    swap_kwargs_callback(this_kwargs)
    #log.debug("fn: %s, args: $s", repr(dpg_fn), str(this_kwargs))

    if child_content_slice:
        node_with_the_children = next((x for x in node.children \
                                       if _n(x)=="c_children"),None)
        #print(json.dumps(node_props(node_with_the_children,""), indent=4))
        if node_with_the_children:

            sliced = [x.children[0] \
                      for x in node_with_the_children.children[child_content_slice]]
            if child_content_slice.stop > 1:
                content = [parse_value(x) for x in sliced]
            elif child_content_slice.stop == 1 and len(sliced):
                content = parse_value(sliced[0])
            else:
                content = ""
        else:
            content = ""

        self = dpg_fn(content, **this_kwargs)
        parse_bindings(node,self)

    else:
        self = dpg_fn(**this_kwargs)
        parse_bindings(node,self)

        children = next((x.children for x in node.children if _n(x)=="c_children"),None)
        for child in children: # these are choice elements
            # recurse create children
            parse_dpg_elem(child.children[0], self)

    # print("created:", self)
    return self

