;===============================================================================
; KeyValues Class
;   by mfaizsyahmi aka kimilil, 2022
;	Last update 2023-02-19
;
; LICENSE: MIT License
;   Read at: https://mit-license.org/
;
; INFO
;	An AHK library that aims to support [de]serialization of the KeyValues 
;	format as used by Valve in GoldSrc, Source, and Steam.
;	Written to [partially] follow the specs detailed in Valve's Developer Community Wiki:
;	https://developer.valvesoftware.com/wiki/KeyValues
;	(macros e.g. #include are not supported at all.)
;	Incidentally, liblist.gam files are supported due to its structure being similar
;	to a flat keyvalue list (no nested objects.)
;
; Class
;   KeyValues - this class
;   VKV - a shorthand alias
;
;	Note: use one or the other. For example, if you define a custom 
;	  ObjectFactory on VKV, then use VKV for the other methods.
;
; Properties
;   KeyValues.ObjectFactory
;     Sets what to use for new objects. Use of a non-default object that preserves
;     order and has case-sensitivity is recommended. 
;     See: https://www.autohotkey.com/boards/viewtopic.php?p=310596&sid=accbc89162c1c8e584be3bdb05c5a365#p310596
;
; Methods
;   KeyValues.Load(str, [options:=""])
;     Loads values from string
;   KeyValues.Dump(obj, [spacer], [indent], [quote])
;     Serialize obj to string
;   KeyValues.LoadFromFile(path, [encoding:=""], [options:=""])
;     Loads from a file
;   KeyValues.DumpToFile(obj, path, [encoding:=""], [options:=""])
;     Serialize obj to string and write to file
;		
;	See the respective methods for documentation on parametres, return values, and notes.
;
; EXAMPLES
; 	#1: loads and dumps values between string and object:
/*
;		kvObj := KeyValues.Load(kvStr)
;		kvStr := KeyValues.Dump(kvObj)
*/
;	#2: Using a custom ObjectFactory
/*
;		; using a Scripting.Dictionary object allows for:-
;		; - case sensitive keyvalues (important as GoldSrc/source/Steam treats keyvalues' keys case-sensitively)
;		; - consistent read-write order
;		class ScriptingDictionaryWrapper {
;			__New() {
;				this._dict := ComObjCreate("Scripting.Dictionary")
;			}
;			; add methods/getters/setters here for accessing the Scripting.Dictionary instance.
;			; they should mirror AHK's object methods.
;		}
;		; Assigns a new ObjectFactory to the class. 
;		KeyValues.ObjectFactory := ScriptingDictionaryWrapper
;		; Calls to Load* from this point returns instances of the object assigned to ObjectFactory.
;		kvDict := KeyValues.Load(kvStr) ; kvDict is an instance of ScriptingDictionaryWrapper
;		kvStr  := KeyValues.Dump(kvDict) ; dumped string has same keyvalue order as when read
*/
;===============================================================================

class KeyValues {
	; static TOKENS_RE := "O`n)(?P<word>[^\s{}""]+)|(?P<q>[""])(?P<string>(?:\\\k<q>|.|\n)*?)\k<q>|(?P<s>{)|(?P<e>})|(?P<conditional>\[\$\w+\])"
	static TOKENS_RE := "O`nx)" "
	(LTrim % `
		 (?P<word>[^\s{}""]+)		# matches a word
		|(?P<q>[""])(?P<string>(?:\\\k<q>|.|\n)*?)\k<q>		# matches a ""quoted string""
		|(?P<s>{)|(?P<e>})			# matches the {opening and closing} brackets
		|(?P<conditional>\[\$\w+\])	# matches a [$conditional] which appear after a key/value and applies to that kv pair
	)"
	, COMMENT_RE := "m`n)//.*$"
	, _lastFile := ""
	, ObjectFactory := Object
	
	;, SPACER := "`t"
	;, INDENT := "`t"
	
	; for _parseTokens
	, PARSE_ENTITY_LUMP := 0x1
	
	; for _objdump
	, QUOTE_WORD := 0x1
	, QUOTE_NUMBER := 0x2
	, QUOTE_EVERYTHING := 0x3
	
	, DUMP_FILE_SIGNATURE := Format("// GENERATED BY {1} USING {2} ({3} Class)"
		, A_ScriptName, StrSplit(A_LineFile, ["\","/"]).Pop(), this.__Class)
	
	_newObject() {
		if (this.ObjectFactory.__Class)
			return new this.ObjectFactory
		else
			return this.ObjectFactory()
	}
	
	_unescape(str) {
		 str := StrReplace(str, "\\", "\")
		,str := StrReplace(str, "\""", """")
		,str := StrReplace(str, "\n",  "`n")
		,str := StrReplace(str, "\t",  "`t")
		return str
	}
	_escape(str) {
		 str := StrReplace(str, "\", "\\")
		,str := StrReplace(str, """", "\""")
		,str := StrReplace(str, "`n",  "\n")
		,str := StrReplace(str, "`t",  "\t")
		return str
	}
	; key token must NOT be empty
	_isKeyToken(m) {
		If (m["s"] || m["e"])
			return False
		Else 
			Return StrLen(m["word"]) + StrLen(m["string"])
	}
	; value token can be empty or falsy, just not those braces
	_isValueToken(m) {
		return !(m["s"] || m["e"])
	}
	_isConditional(m) {
		return m["conditional"]
	}
	; conditionMatches determines which keyvalue tagged with [$condition] gets added
	; and which get discarded. the default "\s" matches no known tag string, 
	; so all tagged keyvalues get discarded.
	; to preserve tagged keyvalues, provide a regex mhat matches the tag string
	; e.g. "$WIN32", "$XB360", or "$WIN32|$XB360" for both.
	; however, be aware that tags typically apply to duplicate key names
	; so there's a high chance the latter will overwrite the former.
	_parseTokens(byref matchArray, conditionMatches:="\s", options := 0) {
		 objToPopulate := this._newObject()
		,objStack := [] ; stack to keep parent object references
		
		,currentKey := A_Space
		,expectValue := false
		,markedForDeletion := [] ; for [$conditional] keyvalues
		for i, m in matchArray {
			/*
			; FOR DEBUGGING
			If KeyValues._lastFile ~= "appmanifest"
				MsgBox, % Format("{}`ncurKey:{}`nexpectVal:{}`n`n{} {}", m[0], currentKey, expectValue
				,this._isKeyToken(m), this._isValueToken(m))
			*/
			
			; found [$conditional]
			if this._isConditional(m) {
				; if the content of [$conditional] bracket doesn't match,
				; mark the preceding key for deletion
				If (!RegExMatch(SubStr(m.conditional, 2, -1),conditionMatches)) {
					keyToDelete := expectValue ? currentKey : lastKey
					markedForDeletion.Push([objToPopulate, keyToDelete])
				}
				continue ; prevent from being parsed
			}
			
			; a key token
			; NOTE: word or string containing "0" is being evaluated as false
			; so we must check that it's NOT the other tokens or that it's not space
			else if (!expectValue && this._isKeyToken(m)) 
			{
				 currentKey := this._unescape(m["string"] ? m["string"] : m["word"])
				,expectValue := true
			}
			; a value token
			else if (expectValue && this._isValueToken(m)) 
			{
				 objToPopulate[currentKey] := this._unescape(m["string"] ? m["string"] : m["word"])
				,lastKey := currentKey ; for conditionals
				,currentKey := A_Space
				,expectValue := false
			}
			; value token being an opening brace
			; if parsing entity lump, key not required; just push
			else if ((expectValue||options&this.PARSE_ENTITY_LUMP) && m["s"])
			{
				 newObj := this._newObject()
				,(options&this.PARSE_ENTITY_LUMP) 
					? objToPopulate.Push(newObj)
					: objToPopulate[currentKey] := newObj
				,objStack.Push(objToPopulate) ; parent object now on top of stack
				,objToPopulate := newObj ; var now refer to child object
				,currentKey := A_Space
				,expectValue := false
			}
			; closing brace
			else if (!expectValue && m["e"])
			{
				objToPopulate := objStack.Pop() ; var now refer to parent object
			}
			else {
				throw Exception( Format("unexpected token: {}`n_lastFile: {}`nidx: {}, pos: {}, len: {}"
						, m[0]
						, KeyValues._lastFile
						, i, m.Pos(0), m.Len(0))
					, -1)
			}
		}
		
		; go through object-key pairs marked for deletion
		; through invalidation of [$conditional] tags.
		; this is done last because for object values, the tags are before the 
		; opening braces, thus before the value is assigned.
		for _, deletionPair in markedForDeletion
			ObjDelete(deletionPair[1], [deletionPair[2]])
			
		; check if the stack has items. this can be caused by brace imbalance.
		; make sure we return the bottom of the stack.
		if objStack.Length()
			return objStack[1]
		else
			return objToPopulate
	}
	;_objLongestKeyLength(obj) {
	;	; heuristic helper to make pretty aligned dump
	;	len := 0
	;	for k, _ in obj {
	;		len := Max(len, StrLen(k))
	;	}
	;	return len
	;}
	_objDump(byRef obj, level:=0, spacer:="`t", indent:="`t", quote:=0x3) {
		(StrLen(spacer)) ? spacer:=A_Tab : 0
		(StrLen(indent)) ? indent:=A_Tab : 0
		VarSetCapacity(str,10240)
		,_indent := level ? StrReplace(Format("{:0" level "i}",0), "0",indent) : ""
		;Loop % level {
		;	_indent .= indent
		;}
		;keyColWidth := this._objLongestKeyLength(obj)
		
		for k, v in obj {
			; write key
			str .= _indent
				. ((RegExMatch(k, "[\s\n/]") || quote & KeyValues.QUOTE_WORD)
					? Format("""{}""", this._escape(k))
					: k)
			
			; value is object. recurse
			if IsObject(v) {
				str .= Format("`n{1}{{}`n{2}`n{3}{}}`n"
					   , _indent
					   , this._objDump(v, level+1, spacer, indent)
					   , indent)
			} 
			; value is number. quote/not quote depending on "quote" parameter
			else if v is number
			{
				str .= Format(quote & KeyValues.QUOTE_NUMBER 
						? "{}""{}""`n"
						: "{}{}`n"
					, spacer, v)
			}
			; value is non-numeric. always quoted
			else
			{
				str .= Format("{}""{}""`n", spacer, this._escape(v))
			}
		}
		return str
	}
	
	; --------------------------------------------------------------------------
	; METHOD: Load - loads a Valve keyvalue structure from string
	; PARAMETERS:
	;	str		  - raw keyvalue string
	;	options	  - string containing one or more word particles:
	; 	  $[condition]	  - keyvalue with [$tag] matching $condition is preserved, else discarded.
	;					  - separate with | to match multiple tag values e.g. "$tag1|$tag2"
	;	  ents			  - parse entity lump
	;
	; RETURNS:	  - an instance of Object or other custom object specified in ObjectFactory
	;				containing the key-value representation of the data
	;
	; NOTES:
	;	1. Keyvalue files on GoldSrc platform hasn't been observed to use any [$platform] tags,
	;	   but Source games surely does. Make sure to specify at least one platform conditional string
	;	   on Source keyvalue files, or you'll be omitting some data.
	;	2. If you decide to load multiple [$tagged] keyvalues, make sure you specify beforehand
	;	   an ObjectFactory that supports duplicate keys, as these [$tags] often apply to
	;	   the same key names.
	; --------------------------------------------------------------------------
	Load(str, options:="") {
		 RegExMatch(options, "i)\$[\w\|]+", optConditionString)
		,RegExMatch(options, "i)\b(?:ents?|entities)\b", optParseEntities)
		
		; strips comments
		,str := RegExReplace(str, this.COMMENT_RE, "")
		
		; capture all tokens in string
		,matchArray := []
		while (curPos := RegExMatch(str, this.TOKENS_RE, matchObj
								   ,A_Index=1?1:curPos+matchObj.Len(0)+0))
			matchArray.Push(matchObj)
		
		; parse the tokens
		return this._parseTokens(matchArray
			, optConditionString ? optConditionString : "\s"
			, optParseEntities ? this.PARSE_ENTITY_LUMP : 0)
	}
	
	; --------------------------------------------------------------------------
	; METHOD: Dump - converts a key-value object structure to a Valve keyvalue-compatible string format
	; PARAMETERS:
	;	obj		  - enumerable key-value object
	;	spacer	  - [optional] whitespace[s] separating key and value string
	;				defaults to a tab character.
	;	indent	  - [optional] whitespace[s] placed before key on every indentation level
	;				(i.e. when value is another object).
	;				defaults to a tab character.
	;	quote	  - [optional] a bit flag describing how to quote non-string values:
	;				0x1	quotes single "words"
	;				0x2	quotes numbers e.g. "42"
	;
	; RETURNS:	  - Valve keyvalue string representation of the data
	;
	; NOTES:
	;	1. The defaults of this method produces liblist-like values.
	;	2. Any [$tags] on keyvalues loaded previously with Load are not remembered
	;	   so the tag would be lost when dumped.
	; --------------------------------------------------------------------------
	Dump(byRef obj, spacer := "`t", indent:="`t", quote:=0) {
		return this._objDump(obj, 0, spacer, indent, quote)
	}
	
	; --------------------------------------------------------------------------
	; METHOD: LoadFromFile - loads a Valve keyvalue structure from file.
	; PARAMETERS:
	;	path	  - file containing Valve keyvalue-formatted data.
	;	encoding  - [optional] encoding to use to read the values. 
	;				Defaults to the script's file encoding setting (A_FileEncoding).
	;	options	  - [optional] same as in Load().
	;
	; RETURNS:	  - an instance of Object or other custom object specified in ObjectFactory
	;				containing the key-value representation of the data.
	;
	; NOTES:
	;	1. Valve primarily uses UTF-8 with UNIX EOL (\n). 
	;	   The former is important, the latter not so much (except on hand-crafted 
	;	   files with line-spanning quoted values; behaviour of non-escaped termination 
	;	   in values is undefined)
	;	2. Other notes from Load() applies.
	; --------------------------------------------------------------------------	
	LoadFromFile(path, encoding:="", options:="") {
		If encoding {
			lastEncoding := A_FileEncoding
			FileEncoding, % encoding
		}
		FileRead, fileContent, % path
		FileEncoding, % lastEncoding
		KeyValues._lastFile := path
		return this.Load(fileContent,options:="")
	}
	
	; --------------------------------------------------------------------------
	; METHOD: DumpToFile - converts a key-value object structure to a Valve 
	;				keyvalue-compatible string format and writes it to a file.
	; PARAMETERS:
	;	obj		  - enumerable key-value object
	;	path	  - file to write Valve keyvalue-formatted data to.
	;	encoding  - [optional] encoding to use to write the file.
	;				Defaults to the script's file encoding setting (A_FileEncoding).
	;	options	  - [optional] string containing one or more word particles:
	; 	  fsig[0|1]	  - whether to write a file signature (a comment on top of the file 
	;					with the name of the script.)
	;	  quoteN	  - How to quote values. N is a bitflag sum. See the quote parameter on Dump() for values.
	;	  spacer[N|T] - spacer between key and value. N is the number of space characters, T is a tab character
	;	  indent[N|T] - indent on every object value level. N and T values the same as spacer.
	;
	; NOTES:
	;	1. The defaults of this method produces liblist-like values.
	;	2. Any [$tags] on keyvalues loaded previously with Load are not remembered
	;	   so the tag would be lost when dumped.
	;	3. AHK's default encoding setting also writes with UNIX EOL (\n),
	;	   the same as keyvalue files in the wild. To change this, consult the EOL section
	;	   of AHK v1.1's FileOpen documentation:
	;		https://www.autohotkey.com/docs/commands/FileOpen.htm
	;	   and enter appropriate values in this method's encoding parameter.
	;	4. spacer and indent defaults to a single tab.
	; --------------------------------------------------------------------------	
	DumpToFile(byRef obj, path, encoding:="", options:="q0 fsig0") {
		 RegExMatch(options, "i)(?<=fsig)\d", optFileSig)			; write file signature?
		,RegExMatch(options, "i)(?<=q(?:uote)?)\d", optQuoteVal)	; how to quote values
		,RegExMatch(options, "i)(?<=s(?:pacer)?)[\dt]", optSpacer)	; spacer char between key and value
		,RegExMatch(options, "i)(?<=i(?:ndent)?)[\dt]", optIndent)	; indent char between levels
		; if writing res file, opt to quote everything
		,optQuoteVal := (SubStr(path, -4) = ".res") 
			? KeyValues.QUOTE_EVERYTHING 
			: (!StrLen(optQuoteVal)) ? 0 : optQuoteVal
		,optSpacer := (optSpacer ~= "\d") ? Format("{: " optSpacer "s}"," ") : "`t"
		,optIndent := (optIndent ~= "\d") ? Format("{: " optIndent "s}"," ") : "`t"
		
		,fp := FileOpen(path, "w", encoding)
		if !fp
			Throw Exception("Unable to open file", -1)
		if optFileSig
			fo.WriteLine(this.DUMP_FILE_SIGNATURE)
		 fp.Write(this.Dump(obj, optSpacer, optIndent, optQuoteVal))
		,fp.Close()
	}
}

; alias to the above class
class VKV extends KeyValues 
{
}
